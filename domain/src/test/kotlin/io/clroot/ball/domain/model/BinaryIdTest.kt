package io.clroot.ball.domain.model

import io.clroot.ball.domain.model.vo.BinaryId
import io.clroot.ball.domain.model.vo.IdError.InvalidIdError
import io.kotest.assertions.arrow.core.shouldBeLeft
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.string.shouldHaveLength
import io.kotest.matchers.string.shouldMatch
import ulid.ULID

class BinaryIdTest : FunSpec({
    
    context("Basic BinaryId functionality") {
        test("new() should create a new BinaryId with a valid ULID") {
            val binaryId = BinaryId.new()
            binaryId.toString() shouldHaveLength 26
        }

        test("fromString() should create a BinaryId from a valid ULID string") {
            val validUlid = BinaryId.new().toString()
            val result = BinaryId.fromString(validUlid)

            result.shouldBeRight().toString() shouldBe validUlid
        }

        test("fromString() should return InvalidIdError for an invalid ULID string") {
            val invalidUlid = "invalid-ulid"
            val result = BinaryId.fromString(invalidUlid)

            result.shouldBeLeft(InvalidIdError)
        }

        test("fromString() should return InvalidIdError for a ULID with incorrect length") {
            val shortUlid = "12345"
            val result = BinaryId.fromString(shortUlid)

            result.shouldBeLeft(InvalidIdError)
        }

        test("fromString() should return InvalidIdError for a ULID with invalid characters") {
            val invalidCharsUlid =
                "0123456789ABCDEFGHIJKLMNOPQR" // Contains 'I' and 'O' which are not in Crockford's base32
            val result = BinaryId.fromString(invalidCharsUlid)

            result.shouldBeLeft(InvalidIdError)
        }

        test("toString() should return the ULID string") {
            val ulidString = BinaryId.new().toString()
            val binaryId = BinaryId.fromString(ulidString).getOrNull()

            binaryId?.toString() shouldBe ulidString
        }
    }

    context("Binary conversion functionality") {
        test("toBytes() should convert ULID to 16-byte array") {
            val binaryId = BinaryId.new()
            val bytes = binaryId.toBytes()
            
            bytes.size shouldBe 16
        }

        test("fromBytes() should fail with invalid byte length") {
            val invalidBytes = ByteArray(8) // 8 bytes instead of 16
            val result = BinaryId.fromBytes(invalidBytes)
            
            result.shouldBeLeft(InvalidIdError)
        }
    }

    context("Compatibility with ulid-kotlin library") {
        test("our ULID should match the standard pattern") {
            val ourULID = BinaryId.new().toString()
            val libraryULID = ULID.nextULID().toString()
            
            val pattern = Regex("^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$")
            
            ourULID shouldMatch pattern
            libraryULID shouldMatch pattern
        }

        test("should be able to parse ULID generated by ulid-kotlin library") {
            val libraryULID = ULID.nextULID().toString()
            val result = BinaryId.fromString(libraryULID)
            
            result.shouldBeRight().toString() shouldBe libraryULID
        }

        test("timestamp ordering should be preserved") {
            val ids = mutableListOf<BinaryId>()
            
            // Generate multiple IDs with small delays
            repeat(3) {
                ids.add(BinaryId.new())
                Thread.sleep(2) // 2ms delay to ensure different timestamps
            }
            
            // Convert to strings and verify lexicographic ordering
            val stringIds = ids.map { it.toString() }
            val sortedIds = stringIds.sorted()
            
            stringIds shouldBe sortedIds
        }

        test("should generate unique IDs consistently") {
            val ids = (1..100).map { BinaryId.new().toString() }.toSet()
            ids.size shouldBe 100 // All should be unique
        }
    }
})
